[api]: https://api.copyleaks.com
[api:register]: https://api.copyleaks.com/account-ui/register
[api:completed]: https://api.copyleaks.com/documentation/v3/webhooks/completed
[api:newresult]: https://api.copyleaks.com/documentation/v3/webhooks/new-result
[api:source]: https://api.copyleaks.com/documentation/v3/downloads/source
[api:result]: https://api.copyleaks.com/documentation/v3/downloads/result
[api:pdf]: https://api.copyleaks.com/documentation/v3/downloads/report
[api:webhooks]: https://api.copyleaks.com/documentation/v3/webhooks
[api:submit:file]: https://api.copyleaks.com/documentation/v3/education/submit/file
[copyleaks]: https://copyleaks.com
[demo]: https://codesandbox.io/s/github/Copyleaks/plagiarism-report-demo/tree/master/?fontsize=14&hidenavigation=1&module=%2Fsrc%2Fapp%2Fapp.component.ts&theme=dark&view=preview
[demo:img]: https://codesandbox.io/static/img/play-codesandbox.svg
[demo:edit]: https://codesandbox.io/s/github/Copyleaks/plagiarism-report-demo/tree/master/?fontsize=14&hidenavigation=1&module=%2Fsrc%2Fapp%2Fapp.component.ts&theme=dark&view=preview
[npm:page]: https://www.npmjs.com/package/@copyleaks/plagiarism-report
[npm:badge]: https://img.shields.io/npm/v/@copyleaks/plagiarism-report/next.svg?style=flat-square

# Copyleaks plagiarism report

[![npm:badge]][npm:page]
Allow [Copyleaks API][api] users to view the plagiarism report using their downloaded data and present it on their platform. You can view the report anytime without being restricted by the Copyleaks expiration policy (that deletes the report's data after a few months). Use this report to have access to your Copyleaks report anytime without having to build your own UI to present the data.

## [Live demo][demo]

[![demo:img]][demo:edit]

## Requirements

- You should have a [Copyleaks account][api:register] and be able to complete a successful scan and store the results on your end
- Server side application with access to stored Copyleaks reports
- A web application with Angular version 8.x

## Integration

You must use this module with data generated by Copyleaks API. In general these are the steps you should follow:

1. Create an account on [Copyleaks][api:register]
2. Use [Copyleaks API][api] to scan for plagiarism
3. Store the data received from [Completed Webhook][api:completed] on your server / cloud
4. Download and store the [source][api:source], [pdf report][api:pdf] (optional) and [results][api:result] on your server / cloud
5. Create http endpoints to access the stored data (completed, source, pdf-report, results)
6. Present the data in your website via Copyleaks plagiarism report

## Installation

Install using npm

```bash
npm i @copyleaks/plagiarism-report@next
```

This library uses `@angular/material` and `@angular/flex-layout` as peer dependencies. If they are not allready installed on your project, add them.

- `ng add @angular/material` or `npm i @angular/material`
- `npm i @angular/flex-layout`

## Usage

> **Note:**
> Copyleaks plagiarism report is built to work with data received from [Copyleaks API](). The responsibility for storing the data and serving it is in your hands.

Add `CopyleaksReportModule` to your module's imports

```ts
//...
import { CopyleaksReportModule } from "@copyleaks/plagiarism-report";

@NgModule({
  declarations: [AppComponent],
  imports: [
    // ...
    CopyleaksReportModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule {}
```

Add the component to your template

```html
<cr-copyleaks-report> </cr-copyleaks-report>
```

Inject `CopyleaksService` to your Component

```ts
export class SomeComponent {
  constructor(private copyleaksService: CopyleaksService, private http: HttpClient) {
    //...
  }
}
```

### Basic usage

> **Note:**
> This example assumes you have already downloaded and stored the data generated by copyleaks API

The component must be provided with the data generated by Copyleaks API.
As mentioned above, your server must store that data, so your front end could access it via http requests. That means your server should support serving the following data:

- Endpoint to get the [Complete Result][api:completed] of a scan by `scan id`
- Endpoint to get the [Source][api:source] of a scan by `scan id`
- Endpoint to get a specific [Result][api:result] of a scan by `scan id` and a `result id`
- (optional) Endpoint to download the [Pdf][api:pdf] of a scan by `scan id`

**Example for the endpoints mentioned above:**

- `yourwebsite.com/copyleaks/{scanId}/completed`
- `yourwebsite.com/copyleaks/{scanId}/source`
- `yourwebsite.com/copyleaks/{scanId}/results/{resultId}`
- `yourwebsite.com/copyleaks/{scanId}/pdf`

Provide the data with `CopyleaksService` after downloading it from your server.

```ts
@Component({
  // ...
})
export class SomeComponent {
  constructor(private copyleaksService: CopyleaksService, private http: HttpClient) {
    const scanId = "some-scan-id";
    // download the source
    // TODO:
    // USE YOUR SOURCE ENDPOINT
    http
      .get<ScanSource>(`/copyleaks/${scanId}/source`)
      .subscribe(source => copyleaksService.pushDownloadedSource(source));

    // download the complete result
    // TODO:
    // USE YOUR COMPLETE RESULT ENDPOINT
    http.get<CompleteResult>(`/copyleaks/${scanId}/complete`).subscribe(completeResult => {
      copyleaksService.pushCompletedResult(completeResult);
      // download each scan result
      // TODO:
      // USE YOUR RESULT ENDPOINT
      const { internet, database, batch } = completeResult.results;
      for (const result of internet) {
        http
          .get<ScanResult>(`/copyleaks/${scanId}/results/${result.id}`)
          .subscribe(scanResult => copyleaksService.pushScanResult(result.id, scanResult));
      }

      // TODO:
      // USE YOUR RESULT ENDPOINT
      for (const result of database) {
        http
          .get<ScanResult>(`/copyleaks/${scanId}/results/${result.id}`)
          .subscribe(scanResult => copyleaksService.pushScanResult(result.id, scanResult));
      }
      // TODO:
      // USE YOUR RESULT ENDPOINT
      for (const result of batch) {
        http
          .get<ScanResult>(`/copyleaks/${scanId}/results/${result.id}`)
          .subscribe(scanResult => copyleaksService.pushScanResult(result.id, scanResult));
      }
    });
  }
}
```

### progress

While you are downloading the results for the report component, you can display a percentage indicating your progress in doing so.

```ts
@Component({
  // ...
})
export class SomeComponent {
  constructor(private copyleaksService: CopyleaksService, private http: HttpClient) {
    let downloadedResults = 0;
    let totalResults = 0;
    const scanId = "some-scan-id";

    // download the source
    // TODO:
    // USE YOUR SOURCE ENDPOINT
    http
      .get<ScanSource>(`/copyleaks/${scanId}/source`)
      .subscribe(source => copyleaksService.pushDownloadedSource(source));

    // download the complete result
    // TODO:
    // USE YOUR COMPLETE RESULT ENDPOINT
    http.get<CompleteResult>(`/copyleaks/${scanId}/complete`).subscribe(completeResult => {
      copyleaksService.pushCompletedResult(completeResult);

      // download each scan result
      const { internet, database, batch } = completeResult.results;
      totalResults = internet.length + database.length + batch.length;

      // TODO:
      // USE YOUR RESULT ENDPOINT
      for (const result of internet) {
        http.get<ScanResult>(`/copyleaks/${scanId}/results/${result.id}`).subscribe(scanResult => {
          copyleaksService.pushScanResult(result.id, scanResult);
          copyleaksService.setProgress((++downloadedResults / totalResults) * 100);
        });
      }
      // TODO:
      // USE YOUR RESULT ENDPOINT
      for (const result of database) {
        http.get<ScanResult>(`/copyleaks/${scanId}/results/${result.id}`).subscribe(scanResult => {
          copyleaksService.pushScanResult(result.id, scanResult);
          copyleaksService.setProgress((++downloadedResults / totalResults) * 100);
        });
      }
      // TODO:
      // USE YOUR RESULT ENDPOINT
      for (const result of batch) {
        http.get<ScanResult>(`/copyleaks/${scanId}/results/${result.id}`).subscribe(scanResult => {
          copyleaksService.pushScanResult(result.id, scanResult);
          copyleaksService.setProgress((++downloadedResults / totalResults) * 100);
        });
      }
    });
  }
}
```

### Real-Time usage

> **Note:**
> This method is optional and more advanced

Copyleaks' scan process could take a few seconds if there are a lot of results. It is possible to push the API results as they arrive to your server from Copyleaks API. This can be achieved with web sockets.
Copyleaks API can utilize the [New Result Webhook][api:newresult] every time a single result is ready.
This will basically display the result on the results list while it is fetching the actual content of the result.

> **Note:**
> The New Result Webhook sends only a preview of the actual result. You must download the actual result, and pass it to `CopyleaksService`

In general it should flow like this:

1. Use [Copyleaks API][api] to scan for palgiarism while providing the relevent [webhook configuration][api:submit:file].
2. Once a [New Result Webhook][api:newresult] arrived on your server, publish it to the relevant web socket connections.
3. Push the new result data to `CopyleaksService` and start downloading the actual result

**Push NewResult:**

> **Note:**
> This is just an rough example , the implementation of `newResultsListener(scanId)` is under your responsibility

```ts
@Component({
  // ...
})
export class SomeComponent {
  constructor(private copyleaksService: CopyleaksService, private http: HttpClient) {
    const scanId = "some-scan-id";

    // listen to incoming new results
    newResultsListener(scanId).subscribe(newResult => {
      // push the new result to the report
      copyleaksService.pushNewResult(newResult);

      // one of them must contain the result preview.
      const result = newResult.internet[0] || newResult.batch[0] || newResult.database[0];

      // download and push the actual scan result
      http
        .get<ScanResult>(`/copyleaks/${scanId}/results/${result.id}`)
        .subscribe(scanResult => copyleaksService.pushScanResult(result.id, scanResult));
    });
  }
}
```

## Configuration

It is possible to configure the behavior, look and state of the report by providing a config via the following methods:

**Via component input property:**

> **Note:**
> You can pass the complete config or only a portion of it to the `config` input property

```html
<!-- some.component.html -->
<cr-copyleaks-report [config]="config"> </cr-copyleaks-report>
```

```ts
// some.component.ts
@Component({
  // ...
})
export class SomeComponent {
  //default config
  public config: CopyleaksReportConfig = {
    contentMode: "html",
    download: false,
    help: false,
    disableSuspectBackButton: false,
    options: {
      showPageSources: false,
      showOnlyTopResults: true,
      showRelated: true,
      showIdentical: true,
      showMinorChanges: true,
      setAsDefault: false
    },
    scanId: null,
    share: false,
    sourcePage: 1,
    suspectId: null,
    suspectPage: 1,
    viewMode: "one-to-many"
  };
}
```

**Via CopyleaksService:**

> **Note:**
> You can pass the complete config or only a portion of it to the `setConfig()` method

```ts
// some.component.ts
@Component({
  // ...
})
export class SomeComponent {
  // plagiarism report will be shown as html
  showHtml() {
    copyleaksService.setConfig({ contentMode: "html" });
  }
  //...
}
```

## Interaction

The component exposes the following events:
|name| `$event` | description
|---|---|---|
|help| `MouseEvent` | emits when the user clicks the help button |
|share| `MouseEvent` | emits when the user clicks the share button |
|download| `MouseEvent` | emits when the user clicks the download button |
|configChange| `CopyleaksReportConfig` | emits when the config is changed |

## FAQ

**My website is not using Angular 8, can I use this component?**
No, this component is supported by Angular `v8.x`.
As an alternative you can create an Angular web application that uses this libarary, and include it in your website using routing. This solution should work without any framework or with other web frameworkds/libraries such as React, AngularJs.

**Can I modify this component for my own usage?**
Modifying the component is allowed according to the [License](./license).
